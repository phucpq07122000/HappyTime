{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"style\"],\n  _excluded2 = [\"style\"],\n  _excluded3 = [\"style\"];\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { unstable_useForkRef as useForkRef, unstable_useEnhancedEffect as useEnhancedEffect } from '@mui/utils';\nimport { useTheme } from '@mui/material/styles';\nimport { defaultMemoize } from 'reselect';\nimport { useGridPrivateApiContext } from '../../utils/useGridPrivateApiContext';\nimport { useGridRootProps } from '../../utils/useGridRootProps';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { gridVisibleColumnDefinitionsSelector, gridColumnsTotalWidthSelector, gridColumnPositionsSelector } from '../columns/gridColumnsSelector';\nimport { gridFocusCellSelector, gridTabIndexCellSelector } from '../focus/gridFocusStateSelector';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { clamp } from '../../../utils/utils';\nimport { selectedIdsLookupSelector } from '../rowSelection/gridRowSelectionSelector';\nimport { gridRowsMetaSelector } from '../rows/gridRowsMetaSelector';\nimport { getFirstNonSpannedColumnToRender } from '../columns/gridColumnsUtils';\nimport { getMinimalContentHeight } from '../rows/gridRowsUtils';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n// Uses binary search to avoid looping through all possible positions\nexport function binarySearch(offset, positions) {\n  let sliceStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let sliceEnd = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : positions.length;\n  if (positions.length <= 0) {\n    return -1;\n  }\n  if (sliceStart >= sliceEnd) {\n    return sliceStart;\n  }\n  const pivot = sliceStart + Math.floor((sliceEnd - sliceStart) / 2);\n  const itemOffset = positions[pivot];\n  return offset <= itemOffset ? binarySearch(offset, positions, sliceStart, pivot) : binarySearch(offset, positions, pivot + 1, sliceEnd);\n}\nfunction exponentialSearch(offset, positions, index) {\n  let interval = 1;\n  while (index < positions.length && Math.abs(positions[index]) < offset) {\n    index += interval;\n    interval *= 2;\n  }\n  return binarySearch(offset, positions, Math.floor(index / 2), Math.min(index, positions.length));\n}\nexport const getRenderableIndexes = _ref4 => {\n  let {\n    firstIndex,\n    lastIndex,\n    buffer,\n    minFirstIndex,\n    maxLastIndex\n  } = _ref4;\n  return [clamp(firstIndex - buffer, minFirstIndex, maxLastIndex), clamp(lastIndex + buffer, minFirstIndex, maxLastIndex)];\n};\nconst areRenderContextsEqual = (context1, context2) => {\n  if (context1 === context2) {\n    return true;\n  }\n  return context1.firstRowIndex === context2.firstRowIndex && context1.lastRowIndex === context2.lastRowIndex && context1.firstColumnIndex === context2.firstColumnIndex && context1.lastColumnIndex === context2.lastColumnIndex;\n};\nexport const useGridVirtualScroller = props => {\n  var _currentPage$range3, _currentPage$range4;\n  const apiRef = useGridPrivateApiContext();\n  const rootProps = useGridRootProps();\n  const visibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);\n  const {\n    ref,\n    disableVirtualization,\n    onRenderZonePositioning,\n    renderZoneMinColumnIndex = 0,\n    renderZoneMaxColumnIndex = visibleColumns.length,\n    getRowProps\n  } = props;\n  const theme = useTheme();\n  const columnPositions = useGridSelector(apiRef, gridColumnPositionsSelector);\n  const columnsTotalWidth = useGridSelector(apiRef, gridColumnsTotalWidthSelector);\n  const cellFocus = useGridSelector(apiRef, gridFocusCellSelector);\n  const cellTabIndex = useGridSelector(apiRef, gridTabIndexCellSelector);\n  const rowsMeta = useGridSelector(apiRef, gridRowsMetaSelector);\n  const selectedRowsLookup = useGridSelector(apiRef, selectedIdsLookupSelector);\n  const currentPage = useGridVisibleRows(apiRef, rootProps);\n  const renderZoneRef = React.useRef(null);\n  const rootRef = React.useRef(null);\n  const handleRef = useForkRef(ref, rootRef);\n  const [renderContext, setRenderContext] = React.useState(null);\n  const prevRenderContext = React.useRef(renderContext);\n  const scrollPosition = React.useRef({\n    top: 0,\n    left: 0\n  });\n  const [containerDimensions, setContainerDimensions] = React.useState({\n    width: null,\n    height: null\n  });\n  const prevTotalWidth = React.useRef(columnsTotalWidth);\n  const rowStyleCache = React.useRef({});\n  const prevGetRowProps = React.useRef();\n  const prevRootRowStyle = React.useRef();\n  const getRenderedColumnsRef = React.useRef(defaultMemoize((columns, firstColumnToRender, lastColumnToRender) => {\n    return columns.slice(firstColumnToRender, lastColumnToRender);\n  }));\n  const getNearestIndexToRender = React.useCallback(offset => {\n    var _currentPage$range, _currentPage$range2;\n    const lastMeasuredIndexRelativeToAllRows = apiRef.current.getLastMeasuredRowIndex();\n    let allRowsMeasured = lastMeasuredIndexRelativeToAllRows === Infinity;\n    if ((_currentPage$range = currentPage.range) != null && _currentPage$range.lastRowIndex && !allRowsMeasured) {\n      // Check if all rows in this page are already measured\n      allRowsMeasured = lastMeasuredIndexRelativeToAllRows >= currentPage.range.lastRowIndex;\n    }\n    const lastMeasuredIndexRelativeToCurrentPage = clamp(lastMeasuredIndexRelativeToAllRows - (((_currentPage$range2 = currentPage.range) == null ? void 0 : _currentPage$range2.firstRowIndex) || 0), 0, rowsMeta.positions.length);\n    if (allRowsMeasured || rowsMeta.positions[lastMeasuredIndexRelativeToCurrentPage] >= offset) {\n      // If all rows were measured (when no row has \"auto\" as height) or all rows before the offset\n      // were measured, then use a binary search because it's faster.\n      return binarySearch(offset, rowsMeta.positions);\n    }\n\n    // Otherwise, use an exponential search.\n    // If rows have \"auto\" as height, their positions will be based on estimated heights.\n    // In this case, we can skip several steps until we find a position higher than the offset.\n    // Inspired by https://github.com/bvaughn/react-virtualized/blob/master/source/Grid/utils/CellSizeAndPositionManager.js\n    return exponentialSearch(offset, rowsMeta.positions, lastMeasuredIndexRelativeToCurrentPage);\n  }, [apiRef, (_currentPage$range3 = currentPage.range) == null ? void 0 : _currentPage$range3.firstRowIndex, (_currentPage$range4 = currentPage.range) == null ? void 0 : _currentPage$range4.lastRowIndex, rowsMeta.positions]);\n  const computeRenderContext = React.useCallback(() => {\n    if (disableVirtualization) {\n      return {\n        firstRowIndex: 0,\n        lastRowIndex: currentPage.rows.length,\n        firstColumnIndex: 0,\n        lastColumnIndex: visibleColumns.length\n      };\n    }\n    const {\n      top,\n      left\n    } = scrollPosition.current;\n\n    // Clamp the value because the search may return an index out of bounds.\n    // In the last index, this is not needed because Array.slice doesn't include it.\n    const firstRowIndex = Math.min(getNearestIndexToRender(top), rowsMeta.positions.length - 1);\n    const lastRowIndex = rootProps.autoHeight ? firstRowIndex + currentPage.rows.length : getNearestIndexToRender(top + containerDimensions.height);\n    let hasRowWithAutoHeight = false;\n    let firstColumnIndex = 0;\n    let lastColumnIndex = columnPositions.length;\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: firstRowIndex,\n      lastIndex: lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rootProps.rowBuffer\n    });\n    for (let i = firstRowToRender; i < lastRowToRender && !hasRowWithAutoHeight; i += 1) {\n      const row = currentPage.rows[i];\n      hasRowWithAutoHeight = apiRef.current.rowHasAutoHeight(row.id);\n    }\n    if (!hasRowWithAutoHeight) {\n      firstColumnIndex = binarySearch(Math.abs(left), columnPositions);\n      lastColumnIndex = binarySearch(Math.abs(left) + containerDimensions.width, columnPositions);\n    }\n    return {\n      firstRowIndex,\n      lastRowIndex,\n      firstColumnIndex,\n      lastColumnIndex\n    };\n  }, [disableVirtualization, getNearestIndexToRender, rowsMeta.positions.length, rootProps.autoHeight, rootProps.rowBuffer, currentPage.rows, columnPositions, visibleColumns.length, apiRef, containerDimensions]);\n  useEnhancedEffect(() => {\n    if (disableVirtualization) {\n      renderZoneRef.current.style.transform = `translate3d(0px, 0px, 0px)`;\n    } else {\n      // TODO a scroll reset should not be necessary\n      rootRef.current.scrollLeft = 0;\n      rootRef.current.scrollTop = 0;\n    }\n  }, [disableVirtualization]);\n  useEnhancedEffect(() => {\n    setContainerDimensions({\n      width: rootRef.current.clientWidth,\n      height: rootRef.current.clientHeight\n    });\n  }, [rowsMeta.currentPageTotalHeight]);\n  const handleResize = React.useCallback(() => {\n    if (rootRef.current) {\n      setContainerDimensions({\n        width: rootRef.current.clientWidth,\n        height: rootRef.current.clientHeight\n      });\n    }\n  }, []);\n  useGridApiEventHandler(apiRef, 'debouncedResize', handleResize);\n  const updateRenderZonePosition = React.useCallback(nextRenderContext => {\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstRowIndex,\n      lastIndex: nextRenderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rootProps.rowBuffer\n    });\n    const [initialFirstColumnToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstColumnIndex,\n      lastIndex: nextRenderContext.lastColumnIndex,\n      minFirstIndex: renderZoneMinColumnIndex,\n      maxLastIndex: renderZoneMaxColumnIndex,\n      buffer: rootProps.columnBuffer\n    });\n    const firstColumnToRender = getFirstNonSpannedColumnToRender({\n      firstColumnToRender: initialFirstColumnToRender,\n      apiRef,\n      firstRowToRender,\n      lastRowToRender,\n      visibleRows: currentPage.rows\n    });\n    const direction = theme.direction === 'ltr' ? 1 : -1;\n    const top = gridRowsMetaSelector(apiRef.current.state).positions[firstRowToRender];\n    const left = direction * gridColumnPositionsSelector(apiRef)[firstColumnToRender]; // Call directly the selector because it might be outdated when this method is called\n    renderZoneRef.current.style.transform = `translate3d(${left}px, ${top}px, 0px)`;\n    if (typeof onRenderZonePositioning === 'function') {\n      onRenderZonePositioning({\n        top,\n        left\n      });\n    }\n  }, [apiRef, currentPage.rows, onRenderZonePositioning, renderZoneMinColumnIndex, renderZoneMaxColumnIndex, rootProps.columnBuffer, rootProps.rowBuffer, theme.direction]);\n  const updateRenderContext = React.useCallback(nextRenderContext => {\n    if (prevRenderContext.current && areRenderContextsEqual(nextRenderContext, prevRenderContext.current)) {\n      updateRenderZonePosition(nextRenderContext);\n      return;\n    }\n    setRenderContext(nextRenderContext);\n    updateRenderZonePosition(nextRenderContext);\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstRowIndex,\n      lastIndex: nextRenderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rootProps.rowBuffer\n    });\n    apiRef.current.publishEvent('renderedRowsIntervalChange', {\n      firstRowToRender,\n      lastRowToRender\n    });\n    prevRenderContext.current = nextRenderContext;\n  }, [apiRef, setRenderContext, prevRenderContext, currentPage.rows.length, rootProps.rowBuffer, updateRenderZonePosition]);\n  useEnhancedEffect(() => {\n    if (containerDimensions.width == null) {\n      return;\n    }\n    const initialRenderContext = computeRenderContext();\n    updateRenderContext(initialRenderContext);\n    const {\n      top,\n      left\n    } = scrollPosition.current;\n    const params = {\n      top,\n      left,\n      renderContext: initialRenderContext\n    };\n    apiRef.current.publishEvent('scrollPositionChange', params);\n  }, [apiRef, computeRenderContext, containerDimensions.width, updateRenderContext]);\n  const handleScroll = event => {\n    const {\n      scrollTop,\n      scrollLeft\n    } = event.currentTarget;\n    scrollPosition.current.top = scrollTop;\n    scrollPosition.current.left = scrollLeft;\n\n    // On iOS and macOS, negative offsets are possible when swiping past the start\n    if (!prevRenderContext.current || scrollTop < 0) {\n      return;\n    }\n    if (theme.direction === 'ltr') {\n      if (scrollLeft < 0) {\n        return;\n      }\n    }\n    if (theme.direction === 'rtl') {\n      if (scrollLeft > 0) {\n        return;\n      }\n    }\n\n    // When virtualization is disabled, the context never changes during scroll\n    const nextRenderContext = disableVirtualization ? prevRenderContext.current : computeRenderContext();\n    const topRowsScrolledSincePreviousRender = Math.abs(nextRenderContext.firstRowIndex - prevRenderContext.current.firstRowIndex);\n    const bottomRowsScrolledSincePreviousRender = Math.abs(nextRenderContext.lastRowIndex - prevRenderContext.current.lastRowIndex);\n    const topColumnsScrolledSincePreviousRender = Math.abs(nextRenderContext.firstColumnIndex - prevRenderContext.current.firstColumnIndex);\n    const bottomColumnsScrolledSincePreviousRender = Math.abs(nextRenderContext.lastColumnIndex - prevRenderContext.current.lastColumnIndex);\n    const shouldSetState = topRowsScrolledSincePreviousRender >= rootProps.rowThreshold || bottomRowsScrolledSincePreviousRender >= rootProps.rowThreshold || topColumnsScrolledSincePreviousRender >= rootProps.columnThreshold || bottomColumnsScrolledSincePreviousRender >= rootProps.columnThreshold || prevTotalWidth.current !== columnsTotalWidth;\n    apiRef.current.publishEvent('scrollPositionChange', {\n      top: scrollTop,\n      left: scrollLeft,\n      renderContext: shouldSetState ? nextRenderContext : prevRenderContext.current\n    }, event);\n    if (shouldSetState) {\n      // Prevents batching render context changes\n      ReactDOM.flushSync(() => {\n        updateRenderContext(nextRenderContext);\n      });\n      prevTotalWidth.current = columnsTotalWidth;\n    }\n  };\n  const handleWheel = event => {\n    apiRef.current.publishEvent('virtualScrollerWheel', {}, event);\n  };\n  const handleTouchMove = event => {\n    apiRef.current.publishEvent('virtualScrollerTouchMove', {}, event);\n  };\n  const getRows = function () {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      renderContext\n    };\n    var _rootProps$slotProps;\n    const {\n      onRowRender,\n      renderContext: nextRenderContext,\n      minFirstColumn = renderZoneMinColumnIndex,\n      maxLastColumn = renderZoneMaxColumnIndex,\n      availableSpace = containerDimensions.width,\n      rowIndexOffset = 0,\n      position = 'center'\n    } = params;\n    if (!nextRenderContext || availableSpace == null) {\n      return null;\n    }\n    const rowBuffer = !disableVirtualization ? rootProps.rowBuffer : 0;\n    const columnBuffer = !disableVirtualization ? rootProps.columnBuffer : 0;\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstRowIndex,\n      lastIndex: nextRenderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rowBuffer\n    });\n    const renderedRows = [];\n    if (params.rows) {\n      params.rows.forEach(row => {\n        renderedRows.push(row);\n        apiRef.current.calculateColSpan({\n          rowId: row.id,\n          minFirstColumn,\n          maxLastColumn,\n          columns: visibleColumns\n        });\n      });\n    } else {\n      if (!currentPage.range) {\n        return null;\n      }\n      for (let i = firstRowToRender; i < lastRowToRender; i += 1) {\n        const row = currentPage.rows[i];\n        renderedRows.push(row);\n        apiRef.current.calculateColSpan({\n          rowId: row.id,\n          minFirstColumn,\n          maxLastColumn,\n          columns: visibleColumns\n        });\n      }\n    }\n    const [initialFirstColumnToRender, lastColumnToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstColumnIndex,\n      lastIndex: nextRenderContext.lastColumnIndex,\n      minFirstIndex: minFirstColumn,\n      maxLastIndex: maxLastColumn,\n      buffer: columnBuffer\n    });\n    const firstColumnToRender = getFirstNonSpannedColumnToRender({\n      firstColumnToRender: initialFirstColumnToRender,\n      apiRef,\n      firstRowToRender,\n      lastRowToRender,\n      visibleRows: currentPage.rows\n    });\n    const renderedColumns = getRenderedColumnsRef.current(visibleColumns, firstColumnToRender, lastColumnToRender);\n    const _ref = ((_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.row) || {},\n      {\n        style: rootRowStyle\n      } = _ref,\n      rootRowProps = _objectWithoutPropertiesLoose(_ref, _excluded);\n    const invalidatesCachedRowStyle = prevGetRowProps.current !== getRowProps || prevRootRowStyle.current !== rootRowStyle;\n    if (invalidatesCachedRowStyle) {\n      rowStyleCache.current = {};\n    }\n    const rows = [];\n    for (let i = 0; i < renderedRows.length; i += 1) {\n      var _currentPage$range5;\n      const {\n        id,\n        model\n      } = renderedRows[i];\n      const lastVisibleRowIndex = firstRowToRender + i === currentPage.rows.length - 1;\n      const baseRowHeight = !apiRef.current.rowHasAutoHeight(id) ? apiRef.current.unstable_getRowHeight(id) : 'auto';\n      let isSelected;\n      if (selectedRowsLookup[id] == null) {\n        isSelected = false;\n      } else {\n        isSelected = apiRef.current.isRowSelectable(id);\n      }\n      if (onRowRender) {\n        onRowRender(id);\n      }\n      const focusedCell = cellFocus !== null && cellFocus.id === id ? cellFocus.field : null;\n      let tabbableCell = null;\n      if (cellTabIndex !== null && cellTabIndex.id === id) {\n        const cellParams = apiRef.current.getCellParams(id, cellTabIndex.field);\n        tabbableCell = cellParams.cellMode === 'view' ? cellTabIndex.field : null;\n      }\n      const _ref2 = typeof getRowProps === 'function' && getRowProps(id, model) || {},\n        {\n          style: rowStyle\n        } = _ref2,\n        rowProps = _objectWithoutPropertiesLoose(_ref2, _excluded2);\n      if (!rowStyleCache.current[id]) {\n        const style = _extends({}, rowStyle, rootRowStyle);\n        rowStyleCache.current[id] = style;\n      }\n      rows.push( /*#__PURE__*/_jsx(rootProps.slots.row, _extends({\n        row: model,\n        rowId: id,\n        rowHeight: baseRowHeight,\n        focusedCell: focusedCell,\n        tabbableCell: tabbableCell,\n        renderedColumns: renderedColumns,\n        visibleColumns: visibleColumns,\n        firstColumnToRender: firstColumnToRender,\n        lastColumnToRender: lastColumnToRender,\n        selected: isSelected,\n        index: rowIndexOffset + ((currentPage == null ? void 0 : (_currentPage$range5 = currentPage.range) == null ? void 0 : _currentPage$range5.firstRowIndex) || 0) + firstRowToRender + i,\n        containerWidth: availableSpace,\n        isLastVisible: lastVisibleRowIndex,\n        position: position\n      }, rowProps, rootRowProps, {\n        style: rowStyleCache.current[id]\n      }), id));\n    }\n    prevGetRowProps.current = getRowProps;\n    prevRootRowStyle.current = rootRowStyle;\n    return rows;\n  };\n  const needsHorizontalScrollbar = containerDimensions.width && columnsTotalWidth >= containerDimensions.width;\n  const contentSize = React.useMemo(() => {\n    // In cases where the columns exceed the available width,\n    // the horizontal scrollbar should be shown even when there're no rows.\n    // Keeping 1px as minimum height ensures that the scrollbar will visible if necessary.\n    const height = Math.max(rowsMeta.currentPageTotalHeight, 1);\n    let shouldExtendContent = false;\n    if (rootRef != null && rootRef.current && height <= (rootRef == null ? void 0 : rootRef.current.clientHeight)) {\n      shouldExtendContent = true;\n    }\n    const size = {\n      width: needsHorizontalScrollbar ? columnsTotalWidth : 'auto',\n      height,\n      minHeight: shouldExtendContent ? '100%' : 'auto'\n    };\n    return size;\n  }, [rootRef, columnsTotalWidth, rowsMeta.currentPageTotalHeight, needsHorizontalScrollbar]);\n  React.useEffect(() => {\n    apiRef.current.publishEvent('virtualScrollerContentSizeChange');\n  }, [apiRef, contentSize]);\n  if (rootProps.autoHeight && currentPage.rows.length === 0) {\n    contentSize.height = getMinimalContentHeight(apiRef, rootProps.rowHeight); // Give room to show the overlay when there no rows.\n  }\n\n  const rootStyle = {};\n  if (!needsHorizontalScrollbar) {\n    rootStyle.overflowX = 'hidden';\n  }\n  if (rootProps.autoHeight) {\n    rootStyle.overflowY = 'hidden';\n  }\n  const getRenderContext = React.useCallback(() => {\n    return prevRenderContext.current;\n  }, []);\n  apiRef.current.register('private', {\n    getRenderContext\n  });\n  return {\n    renderContext,\n    updateRenderZonePosition,\n    getRows,\n    getRootProps: function () {\n      let _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      let {\n          style = {}\n        } = _ref3,\n        other = _objectWithoutPropertiesLoose(_ref3, _excluded3);\n      return _extends({\n        ref: handleRef,\n        onScroll: handleScroll,\n        onWheel: handleWheel,\n        onTouchMove: handleTouchMove,\n        style: _extends({}, style, rootStyle)\n      }, other);\n    },\n    getContentProps: function () {\n      let {\n        style = {}\n      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return {\n        style: _extends({}, style, contentSize)\n      };\n    },\n    getRenderZoneProps: () => ({\n      ref: renderZoneRef\n    })\n  };\n};","map":{"version":3,"names":["_extends","_objectWithoutPropertiesLoose","_excluded","_excluded2","_excluded3","React","ReactDOM","unstable_useForkRef","useForkRef","unstable_useEnhancedEffect","useEnhancedEffect","useTheme","defaultMemoize","useGridPrivateApiContext","useGridRootProps","useGridSelector","gridVisibleColumnDefinitionsSelector","gridColumnsTotalWidthSelector","gridColumnPositionsSelector","gridFocusCellSelector","gridTabIndexCellSelector","useGridVisibleRows","useGridApiEventHandler","clamp","selectedIdsLookupSelector","gridRowsMetaSelector","getFirstNonSpannedColumnToRender","getMinimalContentHeight","jsx","_jsx","binarySearch","offset","positions","sliceStart","arguments","length","undefined","sliceEnd","pivot","Math","floor","itemOffset","exponentialSearch","index","interval","abs","min","getRenderableIndexes","_ref4","firstIndex","lastIndex","buffer","minFirstIndex","maxLastIndex","areRenderContextsEqual","context1","context2","firstRowIndex","lastRowIndex","firstColumnIndex","lastColumnIndex","useGridVirtualScroller","props","_currentPage$range3","_currentPage$range4","apiRef","rootProps","visibleColumns","ref","disableVirtualization","onRenderZonePositioning","renderZoneMinColumnIndex","renderZoneMaxColumnIndex","getRowProps","theme","columnPositions","columnsTotalWidth","cellFocus","cellTabIndex","rowsMeta","selectedRowsLookup","currentPage","renderZoneRef","useRef","rootRef","handleRef","renderContext","setRenderContext","useState","prevRenderContext","scrollPosition","top","left","containerDimensions","setContainerDimensions","width","height","prevTotalWidth","rowStyleCache","prevGetRowProps","prevRootRowStyle","getRenderedColumnsRef","columns","firstColumnToRender","lastColumnToRender","slice","getNearestIndexToRender","useCallback","_currentPage$range","_currentPage$range2","lastMeasuredIndexRelativeToAllRows","current","getLastMeasuredRowIndex","allRowsMeasured","Infinity","range","lastMeasuredIndexRelativeToCurrentPage","computeRenderContext","rows","autoHeight","hasRowWithAutoHeight","firstRowToRender","lastRowToRender","rowBuffer","i","row","rowHasAutoHeight","id","style","transform","scrollLeft","scrollTop","clientWidth","clientHeight","currentPageTotalHeight","handleResize","updateRenderZonePosition","nextRenderContext","initialFirstColumnToRender","columnBuffer","visibleRows","direction","state","updateRenderContext","publishEvent","initialRenderContext","params","handleScroll","event","currentTarget","topRowsScrolledSincePreviousRender","bottomRowsScrolledSincePreviousRender","topColumnsScrolledSincePreviousRender","bottomColumnsScrolledSincePreviousRender","shouldSetState","rowThreshold","columnThreshold","flushSync","handleWheel","handleTouchMove","getRows","_rootProps$slotProps","onRowRender","minFirstColumn","maxLastColumn","availableSpace","rowIndexOffset","position","renderedRows","forEach","push","calculateColSpan","rowId","renderedColumns","_ref","slotProps","rootRowStyle","rootRowProps","invalidatesCachedRowStyle","_currentPage$range5","model","lastVisibleRowIndex","baseRowHeight","unstable_getRowHeight","isSelected","isRowSelectable","focusedCell","field","tabbableCell","cellParams","getCellParams","cellMode","_ref2","rowStyle","rowProps","slots","rowHeight","selected","containerWidth","isLastVisible","needsHorizontalScrollbar","contentSize","useMemo","max","shouldExtendContent","size","minHeight","useEffect","rootStyle","overflowX","overflowY","getRenderContext","register","getRootProps","_ref3","other","onScroll","onWheel","onTouchMove","getContentProps","getRenderZoneProps"],"sources":["C:/Users/Tran Ho/Desktop/happy_time/HappyTime/happytime/node_modules/@mui/x-data-grid/hooks/features/virtualization/useGridVirtualScroller.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"style\"],\n  _excluded2 = [\"style\"],\n  _excluded3 = [\"style\"];\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { unstable_useForkRef as useForkRef, unstable_useEnhancedEffect as useEnhancedEffect } from '@mui/utils';\nimport { useTheme } from '@mui/material/styles';\nimport { defaultMemoize } from 'reselect';\nimport { useGridPrivateApiContext } from '../../utils/useGridPrivateApiContext';\nimport { useGridRootProps } from '../../utils/useGridRootProps';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { gridVisibleColumnDefinitionsSelector, gridColumnsTotalWidthSelector, gridColumnPositionsSelector } from '../columns/gridColumnsSelector';\nimport { gridFocusCellSelector, gridTabIndexCellSelector } from '../focus/gridFocusStateSelector';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { clamp } from '../../../utils/utils';\nimport { selectedIdsLookupSelector } from '../rowSelection/gridRowSelectionSelector';\nimport { gridRowsMetaSelector } from '../rows/gridRowsMetaSelector';\nimport { getFirstNonSpannedColumnToRender } from '../columns/gridColumnsUtils';\nimport { getMinimalContentHeight } from '../rows/gridRowsUtils';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n// Uses binary search to avoid looping through all possible positions\nexport function binarySearch(offset, positions, sliceStart = 0, sliceEnd = positions.length) {\n  if (positions.length <= 0) {\n    return -1;\n  }\n  if (sliceStart >= sliceEnd) {\n    return sliceStart;\n  }\n  const pivot = sliceStart + Math.floor((sliceEnd - sliceStart) / 2);\n  const itemOffset = positions[pivot];\n  return offset <= itemOffset ? binarySearch(offset, positions, sliceStart, pivot) : binarySearch(offset, positions, pivot + 1, sliceEnd);\n}\nfunction exponentialSearch(offset, positions, index) {\n  let interval = 1;\n  while (index < positions.length && Math.abs(positions[index]) < offset) {\n    index += interval;\n    interval *= 2;\n  }\n  return binarySearch(offset, positions, Math.floor(index / 2), Math.min(index, positions.length));\n}\nexport const getRenderableIndexes = ({\n  firstIndex,\n  lastIndex,\n  buffer,\n  minFirstIndex,\n  maxLastIndex\n}) => {\n  return [clamp(firstIndex - buffer, minFirstIndex, maxLastIndex), clamp(lastIndex + buffer, minFirstIndex, maxLastIndex)];\n};\nconst areRenderContextsEqual = (context1, context2) => {\n  if (context1 === context2) {\n    return true;\n  }\n  return context1.firstRowIndex === context2.firstRowIndex && context1.lastRowIndex === context2.lastRowIndex && context1.firstColumnIndex === context2.firstColumnIndex && context1.lastColumnIndex === context2.lastColumnIndex;\n};\nexport const useGridVirtualScroller = props => {\n  var _currentPage$range3, _currentPage$range4;\n  const apiRef = useGridPrivateApiContext();\n  const rootProps = useGridRootProps();\n  const visibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);\n  const {\n    ref,\n    disableVirtualization,\n    onRenderZonePositioning,\n    renderZoneMinColumnIndex = 0,\n    renderZoneMaxColumnIndex = visibleColumns.length,\n    getRowProps\n  } = props;\n  const theme = useTheme();\n  const columnPositions = useGridSelector(apiRef, gridColumnPositionsSelector);\n  const columnsTotalWidth = useGridSelector(apiRef, gridColumnsTotalWidthSelector);\n  const cellFocus = useGridSelector(apiRef, gridFocusCellSelector);\n  const cellTabIndex = useGridSelector(apiRef, gridTabIndexCellSelector);\n  const rowsMeta = useGridSelector(apiRef, gridRowsMetaSelector);\n  const selectedRowsLookup = useGridSelector(apiRef, selectedIdsLookupSelector);\n  const currentPage = useGridVisibleRows(apiRef, rootProps);\n  const renderZoneRef = React.useRef(null);\n  const rootRef = React.useRef(null);\n  const handleRef = useForkRef(ref, rootRef);\n  const [renderContext, setRenderContext] = React.useState(null);\n  const prevRenderContext = React.useRef(renderContext);\n  const scrollPosition = React.useRef({\n    top: 0,\n    left: 0\n  });\n  const [containerDimensions, setContainerDimensions] = React.useState({\n    width: null,\n    height: null\n  });\n  const prevTotalWidth = React.useRef(columnsTotalWidth);\n  const rowStyleCache = React.useRef({});\n  const prevGetRowProps = React.useRef();\n  const prevRootRowStyle = React.useRef();\n  const getRenderedColumnsRef = React.useRef(defaultMemoize((columns, firstColumnToRender, lastColumnToRender) => {\n    return columns.slice(firstColumnToRender, lastColumnToRender);\n  }));\n  const getNearestIndexToRender = React.useCallback(offset => {\n    var _currentPage$range, _currentPage$range2;\n    const lastMeasuredIndexRelativeToAllRows = apiRef.current.getLastMeasuredRowIndex();\n    let allRowsMeasured = lastMeasuredIndexRelativeToAllRows === Infinity;\n    if ((_currentPage$range = currentPage.range) != null && _currentPage$range.lastRowIndex && !allRowsMeasured) {\n      // Check if all rows in this page are already measured\n      allRowsMeasured = lastMeasuredIndexRelativeToAllRows >= currentPage.range.lastRowIndex;\n    }\n    const lastMeasuredIndexRelativeToCurrentPage = clamp(lastMeasuredIndexRelativeToAllRows - (((_currentPage$range2 = currentPage.range) == null ? void 0 : _currentPage$range2.firstRowIndex) || 0), 0, rowsMeta.positions.length);\n    if (allRowsMeasured || rowsMeta.positions[lastMeasuredIndexRelativeToCurrentPage] >= offset) {\n      // If all rows were measured (when no row has \"auto\" as height) or all rows before the offset\n      // were measured, then use a binary search because it's faster.\n      return binarySearch(offset, rowsMeta.positions);\n    }\n\n    // Otherwise, use an exponential search.\n    // If rows have \"auto\" as height, their positions will be based on estimated heights.\n    // In this case, we can skip several steps until we find a position higher than the offset.\n    // Inspired by https://github.com/bvaughn/react-virtualized/blob/master/source/Grid/utils/CellSizeAndPositionManager.js\n    return exponentialSearch(offset, rowsMeta.positions, lastMeasuredIndexRelativeToCurrentPage);\n  }, [apiRef, (_currentPage$range3 = currentPage.range) == null ? void 0 : _currentPage$range3.firstRowIndex, (_currentPage$range4 = currentPage.range) == null ? void 0 : _currentPage$range4.lastRowIndex, rowsMeta.positions]);\n  const computeRenderContext = React.useCallback(() => {\n    if (disableVirtualization) {\n      return {\n        firstRowIndex: 0,\n        lastRowIndex: currentPage.rows.length,\n        firstColumnIndex: 0,\n        lastColumnIndex: visibleColumns.length\n      };\n    }\n    const {\n      top,\n      left\n    } = scrollPosition.current;\n\n    // Clamp the value because the search may return an index out of bounds.\n    // In the last index, this is not needed because Array.slice doesn't include it.\n    const firstRowIndex = Math.min(getNearestIndexToRender(top), rowsMeta.positions.length - 1);\n    const lastRowIndex = rootProps.autoHeight ? firstRowIndex + currentPage.rows.length : getNearestIndexToRender(top + containerDimensions.height);\n    let hasRowWithAutoHeight = false;\n    let firstColumnIndex = 0;\n    let lastColumnIndex = columnPositions.length;\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: firstRowIndex,\n      lastIndex: lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rootProps.rowBuffer\n    });\n    for (let i = firstRowToRender; i < lastRowToRender && !hasRowWithAutoHeight; i += 1) {\n      const row = currentPage.rows[i];\n      hasRowWithAutoHeight = apiRef.current.rowHasAutoHeight(row.id);\n    }\n    if (!hasRowWithAutoHeight) {\n      firstColumnIndex = binarySearch(Math.abs(left), columnPositions);\n      lastColumnIndex = binarySearch(Math.abs(left) + containerDimensions.width, columnPositions);\n    }\n    return {\n      firstRowIndex,\n      lastRowIndex,\n      firstColumnIndex,\n      lastColumnIndex\n    };\n  }, [disableVirtualization, getNearestIndexToRender, rowsMeta.positions.length, rootProps.autoHeight, rootProps.rowBuffer, currentPage.rows, columnPositions, visibleColumns.length, apiRef, containerDimensions]);\n  useEnhancedEffect(() => {\n    if (disableVirtualization) {\n      renderZoneRef.current.style.transform = `translate3d(0px, 0px, 0px)`;\n    } else {\n      // TODO a scroll reset should not be necessary\n      rootRef.current.scrollLeft = 0;\n      rootRef.current.scrollTop = 0;\n    }\n  }, [disableVirtualization]);\n  useEnhancedEffect(() => {\n    setContainerDimensions({\n      width: rootRef.current.clientWidth,\n      height: rootRef.current.clientHeight\n    });\n  }, [rowsMeta.currentPageTotalHeight]);\n  const handleResize = React.useCallback(() => {\n    if (rootRef.current) {\n      setContainerDimensions({\n        width: rootRef.current.clientWidth,\n        height: rootRef.current.clientHeight\n      });\n    }\n  }, []);\n  useGridApiEventHandler(apiRef, 'debouncedResize', handleResize);\n  const updateRenderZonePosition = React.useCallback(nextRenderContext => {\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstRowIndex,\n      lastIndex: nextRenderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rootProps.rowBuffer\n    });\n    const [initialFirstColumnToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstColumnIndex,\n      lastIndex: nextRenderContext.lastColumnIndex,\n      minFirstIndex: renderZoneMinColumnIndex,\n      maxLastIndex: renderZoneMaxColumnIndex,\n      buffer: rootProps.columnBuffer\n    });\n    const firstColumnToRender = getFirstNonSpannedColumnToRender({\n      firstColumnToRender: initialFirstColumnToRender,\n      apiRef,\n      firstRowToRender,\n      lastRowToRender,\n      visibleRows: currentPage.rows\n    });\n    const direction = theme.direction === 'ltr' ? 1 : -1;\n    const top = gridRowsMetaSelector(apiRef.current.state).positions[firstRowToRender];\n    const left = direction * gridColumnPositionsSelector(apiRef)[firstColumnToRender]; // Call directly the selector because it might be outdated when this method is called\n    renderZoneRef.current.style.transform = `translate3d(${left}px, ${top}px, 0px)`;\n    if (typeof onRenderZonePositioning === 'function') {\n      onRenderZonePositioning({\n        top,\n        left\n      });\n    }\n  }, [apiRef, currentPage.rows, onRenderZonePositioning, renderZoneMinColumnIndex, renderZoneMaxColumnIndex, rootProps.columnBuffer, rootProps.rowBuffer, theme.direction]);\n  const updateRenderContext = React.useCallback(nextRenderContext => {\n    if (prevRenderContext.current && areRenderContextsEqual(nextRenderContext, prevRenderContext.current)) {\n      updateRenderZonePosition(nextRenderContext);\n      return;\n    }\n    setRenderContext(nextRenderContext);\n    updateRenderZonePosition(nextRenderContext);\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstRowIndex,\n      lastIndex: nextRenderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rootProps.rowBuffer\n    });\n    apiRef.current.publishEvent('renderedRowsIntervalChange', {\n      firstRowToRender,\n      lastRowToRender\n    });\n    prevRenderContext.current = nextRenderContext;\n  }, [apiRef, setRenderContext, prevRenderContext, currentPage.rows.length, rootProps.rowBuffer, updateRenderZonePosition]);\n  useEnhancedEffect(() => {\n    if (containerDimensions.width == null) {\n      return;\n    }\n    const initialRenderContext = computeRenderContext();\n    updateRenderContext(initialRenderContext);\n    const {\n      top,\n      left\n    } = scrollPosition.current;\n    const params = {\n      top,\n      left,\n      renderContext: initialRenderContext\n    };\n    apiRef.current.publishEvent('scrollPositionChange', params);\n  }, [apiRef, computeRenderContext, containerDimensions.width, updateRenderContext]);\n  const handleScroll = event => {\n    const {\n      scrollTop,\n      scrollLeft\n    } = event.currentTarget;\n    scrollPosition.current.top = scrollTop;\n    scrollPosition.current.left = scrollLeft;\n\n    // On iOS and macOS, negative offsets are possible when swiping past the start\n    if (!prevRenderContext.current || scrollTop < 0) {\n      return;\n    }\n    if (theme.direction === 'ltr') {\n      if (scrollLeft < 0) {\n        return;\n      }\n    }\n    if (theme.direction === 'rtl') {\n      if (scrollLeft > 0) {\n        return;\n      }\n    }\n\n    // When virtualization is disabled, the context never changes during scroll\n    const nextRenderContext = disableVirtualization ? prevRenderContext.current : computeRenderContext();\n    const topRowsScrolledSincePreviousRender = Math.abs(nextRenderContext.firstRowIndex - prevRenderContext.current.firstRowIndex);\n    const bottomRowsScrolledSincePreviousRender = Math.abs(nextRenderContext.lastRowIndex - prevRenderContext.current.lastRowIndex);\n    const topColumnsScrolledSincePreviousRender = Math.abs(nextRenderContext.firstColumnIndex - prevRenderContext.current.firstColumnIndex);\n    const bottomColumnsScrolledSincePreviousRender = Math.abs(nextRenderContext.lastColumnIndex - prevRenderContext.current.lastColumnIndex);\n    const shouldSetState = topRowsScrolledSincePreviousRender >= rootProps.rowThreshold || bottomRowsScrolledSincePreviousRender >= rootProps.rowThreshold || topColumnsScrolledSincePreviousRender >= rootProps.columnThreshold || bottomColumnsScrolledSincePreviousRender >= rootProps.columnThreshold || prevTotalWidth.current !== columnsTotalWidth;\n    apiRef.current.publishEvent('scrollPositionChange', {\n      top: scrollTop,\n      left: scrollLeft,\n      renderContext: shouldSetState ? nextRenderContext : prevRenderContext.current\n    }, event);\n    if (shouldSetState) {\n      // Prevents batching render context changes\n      ReactDOM.flushSync(() => {\n        updateRenderContext(nextRenderContext);\n      });\n      prevTotalWidth.current = columnsTotalWidth;\n    }\n  };\n  const handleWheel = event => {\n    apiRef.current.publishEvent('virtualScrollerWheel', {}, event);\n  };\n  const handleTouchMove = event => {\n    apiRef.current.publishEvent('virtualScrollerTouchMove', {}, event);\n  };\n  const getRows = (params = {\n    renderContext\n  }) => {\n    var _rootProps$slotProps;\n    const {\n      onRowRender,\n      renderContext: nextRenderContext,\n      minFirstColumn = renderZoneMinColumnIndex,\n      maxLastColumn = renderZoneMaxColumnIndex,\n      availableSpace = containerDimensions.width,\n      rowIndexOffset = 0,\n      position = 'center'\n    } = params;\n    if (!nextRenderContext || availableSpace == null) {\n      return null;\n    }\n    const rowBuffer = !disableVirtualization ? rootProps.rowBuffer : 0;\n    const columnBuffer = !disableVirtualization ? rootProps.columnBuffer : 0;\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstRowIndex,\n      lastIndex: nextRenderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rowBuffer\n    });\n    const renderedRows = [];\n    if (params.rows) {\n      params.rows.forEach(row => {\n        renderedRows.push(row);\n        apiRef.current.calculateColSpan({\n          rowId: row.id,\n          minFirstColumn,\n          maxLastColumn,\n          columns: visibleColumns\n        });\n      });\n    } else {\n      if (!currentPage.range) {\n        return null;\n      }\n      for (let i = firstRowToRender; i < lastRowToRender; i += 1) {\n        const row = currentPage.rows[i];\n        renderedRows.push(row);\n        apiRef.current.calculateColSpan({\n          rowId: row.id,\n          minFirstColumn,\n          maxLastColumn,\n          columns: visibleColumns\n        });\n      }\n    }\n    const [initialFirstColumnToRender, lastColumnToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstColumnIndex,\n      lastIndex: nextRenderContext.lastColumnIndex,\n      minFirstIndex: minFirstColumn,\n      maxLastIndex: maxLastColumn,\n      buffer: columnBuffer\n    });\n    const firstColumnToRender = getFirstNonSpannedColumnToRender({\n      firstColumnToRender: initialFirstColumnToRender,\n      apiRef,\n      firstRowToRender,\n      lastRowToRender,\n      visibleRows: currentPage.rows\n    });\n    const renderedColumns = getRenderedColumnsRef.current(visibleColumns, firstColumnToRender, lastColumnToRender);\n    const _ref = ((_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.row) || {},\n      {\n        style: rootRowStyle\n      } = _ref,\n      rootRowProps = _objectWithoutPropertiesLoose(_ref, _excluded);\n    const invalidatesCachedRowStyle = prevGetRowProps.current !== getRowProps || prevRootRowStyle.current !== rootRowStyle;\n    if (invalidatesCachedRowStyle) {\n      rowStyleCache.current = {};\n    }\n    const rows = [];\n    for (let i = 0; i < renderedRows.length; i += 1) {\n      var _currentPage$range5;\n      const {\n        id,\n        model\n      } = renderedRows[i];\n      const lastVisibleRowIndex = firstRowToRender + i === currentPage.rows.length - 1;\n      const baseRowHeight = !apiRef.current.rowHasAutoHeight(id) ? apiRef.current.unstable_getRowHeight(id) : 'auto';\n      let isSelected;\n      if (selectedRowsLookup[id] == null) {\n        isSelected = false;\n      } else {\n        isSelected = apiRef.current.isRowSelectable(id);\n      }\n      if (onRowRender) {\n        onRowRender(id);\n      }\n      const focusedCell = cellFocus !== null && cellFocus.id === id ? cellFocus.field : null;\n      let tabbableCell = null;\n      if (cellTabIndex !== null && cellTabIndex.id === id) {\n        const cellParams = apiRef.current.getCellParams(id, cellTabIndex.field);\n        tabbableCell = cellParams.cellMode === 'view' ? cellTabIndex.field : null;\n      }\n      const _ref2 = typeof getRowProps === 'function' && getRowProps(id, model) || {},\n        {\n          style: rowStyle\n        } = _ref2,\n        rowProps = _objectWithoutPropertiesLoose(_ref2, _excluded2);\n      if (!rowStyleCache.current[id]) {\n        const style = _extends({}, rowStyle, rootRowStyle);\n        rowStyleCache.current[id] = style;\n      }\n      rows.push( /*#__PURE__*/_jsx(rootProps.slots.row, _extends({\n        row: model,\n        rowId: id,\n        rowHeight: baseRowHeight,\n        focusedCell: focusedCell,\n        tabbableCell: tabbableCell,\n        renderedColumns: renderedColumns,\n        visibleColumns: visibleColumns,\n        firstColumnToRender: firstColumnToRender,\n        lastColumnToRender: lastColumnToRender,\n        selected: isSelected,\n        index: rowIndexOffset + ((currentPage == null ? void 0 : (_currentPage$range5 = currentPage.range) == null ? void 0 : _currentPage$range5.firstRowIndex) || 0) + firstRowToRender + i,\n        containerWidth: availableSpace,\n        isLastVisible: lastVisibleRowIndex,\n        position: position\n      }, rowProps, rootRowProps, {\n        style: rowStyleCache.current[id]\n      }), id));\n    }\n    prevGetRowProps.current = getRowProps;\n    prevRootRowStyle.current = rootRowStyle;\n    return rows;\n  };\n  const needsHorizontalScrollbar = containerDimensions.width && columnsTotalWidth >= containerDimensions.width;\n  const contentSize = React.useMemo(() => {\n    // In cases where the columns exceed the available width,\n    // the horizontal scrollbar should be shown even when there're no rows.\n    // Keeping 1px as minimum height ensures that the scrollbar will visible if necessary.\n    const height = Math.max(rowsMeta.currentPageTotalHeight, 1);\n    let shouldExtendContent = false;\n    if (rootRef != null && rootRef.current && height <= (rootRef == null ? void 0 : rootRef.current.clientHeight)) {\n      shouldExtendContent = true;\n    }\n    const size = {\n      width: needsHorizontalScrollbar ? columnsTotalWidth : 'auto',\n      height,\n      minHeight: shouldExtendContent ? '100%' : 'auto'\n    };\n    return size;\n  }, [rootRef, columnsTotalWidth, rowsMeta.currentPageTotalHeight, needsHorizontalScrollbar]);\n  React.useEffect(() => {\n    apiRef.current.publishEvent('virtualScrollerContentSizeChange');\n  }, [apiRef, contentSize]);\n  if (rootProps.autoHeight && currentPage.rows.length === 0) {\n    contentSize.height = getMinimalContentHeight(apiRef, rootProps.rowHeight); // Give room to show the overlay when there no rows.\n  }\n\n  const rootStyle = {};\n  if (!needsHorizontalScrollbar) {\n    rootStyle.overflowX = 'hidden';\n  }\n  if (rootProps.autoHeight) {\n    rootStyle.overflowY = 'hidden';\n  }\n  const getRenderContext = React.useCallback(() => {\n    return prevRenderContext.current;\n  }, []);\n  apiRef.current.register('private', {\n    getRenderContext\n  });\n  return {\n    renderContext,\n    updateRenderZonePosition,\n    getRows,\n    getRootProps: (_ref3 = {}) => {\n      let {\n          style = {}\n        } = _ref3,\n        other = _objectWithoutPropertiesLoose(_ref3, _excluded3);\n      return _extends({\n        ref: handleRef,\n        onScroll: handleScroll,\n        onWheel: handleWheel,\n        onTouchMove: handleTouchMove,\n        style: _extends({}, style, rootStyle)\n      }, other);\n    },\n    getContentProps: ({\n      style = {}\n    } = {}) => ({\n      style: _extends({}, style, contentSize)\n    }),\n    getRenderZoneProps: () => ({\n      ref: renderZoneRef\n    })\n  };\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}